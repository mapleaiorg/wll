use std::collections::BTreeMap;

use serde::{Deserialize, Serialize};
use serde_json::Value;
use wll_types::{CommitmentId, TemporalAnchor, WorldlineId};

// Re-export from wll-types for convenience.
pub use wll_types::commitment::Decision;
pub use wll_types::evidence::EvidenceBundle;
pub use wll_types::receipt::ReceiptKind;

/// Commitment class controls policy tiering at the boundary.
pub use wll_types::CommitmentClass;

/// Commitment proposal generated by a WorldLine operator.
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct CommitmentProposal {
    pub worldline: WorldlineId,
    pub commitment_id: CommitmentId,
    pub class: CommitmentClass,
    pub intent: String,
    pub requested_caps: Vec<String>,
    pub targets: Vec<WorldlineId>,
    pub evidence: EvidenceBundle,
    pub nonce: u64,
}

/// Immutable commitment receipt stored in WLL.
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct CommitmentReceipt {
    pub worldline: WorldlineId,
    pub seq: u64,
    pub receipt_hash: [u8; 32],
    pub prev_hash: Option<[u8; 32]>,
    pub timestamp: TemporalAnchor,
    pub proposal_hash: [u8; 32],
    pub commitment_id: CommitmentId,
    pub class: CommitmentClass,
    pub intent: String,
    pub requested_caps: Vec<String>,
    pub evidence: EvidenceBundle,
    pub decision: Decision,
    pub policy_hash: [u8; 32],
}

/// Human/audit-readable summary of one externally visible effect.
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct EffectSummary {
    pub kind: String,
    pub target: String,
    pub description: String,
}

/// Proof reference (artifact stored outside the ledger).
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct ProofRef {
    pub uri: String,
    pub digest: [u8; 32],
}

/// Canonical update applied to projected state.
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct StateUpdate {
    pub key: String,
    pub value: Value,
}

/// Input payload for accepted outcomes.
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct OutcomeRecord {
    pub effects: Vec<EffectSummary>,
    pub proofs: Vec<ProofRef>,
    pub state_updates: Vec<StateUpdate>,
    pub metadata: BTreeMap<String, String>,
}

impl OutcomeRecord {
    pub fn outcome_hash(&self) -> [u8; 32] {
        let encoded = serde_json::to_vec(self).unwrap_or_default();
        *blake3::hash(&encoded).as_bytes()
    }
}

/// Immutable outcome receipt stored in WLL.
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct OutcomeReceipt {
    pub worldline: WorldlineId,
    pub seq: u64,
    pub receipt_hash: [u8; 32],
    pub prev_hash: Option<[u8; 32]>,
    pub timestamp: TemporalAnchor,
    pub commitment_receipt_hash: [u8; 32],
    pub outcome_hash: [u8; 32],
    pub accepted: bool,
    pub effects: Vec<EffectSummary>,
    pub proofs: Vec<ProofRef>,
    pub state_updates: Vec<StateUpdate>,
    pub metadata: BTreeMap<String, String>,
}

/// Input payload for snapshot writes.
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct SnapshotInput {
    pub worldline: WorldlineId,
    pub anchored_receipt_hash: [u8; 32],
    pub state: BTreeMap<String, Value>,
}

/// Immutable snapshot receipt.
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct SnapshotReceipt {
    pub worldline: WorldlineId,
    pub seq: u64,
    pub receipt_hash: [u8; 32],
    pub prev_hash: Option<[u8; 32]>,
    pub timestamp: TemporalAnchor,
    pub anchored_receipt_hash: [u8; 32],
    pub state_hash: [u8; 32],
    pub state: BTreeMap<String, Value>,
}

/// Unified receipt envelope for append-only streams.
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub enum Receipt {
    Commitment(CommitmentReceipt),
    Outcome(OutcomeReceipt),
    Snapshot(SnapshotReceipt),
}

/// Compact receipt reference returned by head/index queries.
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct ReceiptRef {
    pub worldline: WorldlineId,
    pub seq: u64,
    pub receipt_hash: [u8; 32],
}

impl Receipt {
    pub fn kind(&self) -> ReceiptKind {
        match self {
            Self::Commitment(_) => ReceiptKind::Commitment,
            Self::Outcome(_) => ReceiptKind::Outcome,
            Self::Snapshot(_) => ReceiptKind::Snapshot,
        }
    }

    pub fn worldline(&self) -> &WorldlineId {
        match self {
            Self::Commitment(r) => &r.worldline,
            Self::Outcome(r) => &r.worldline,
            Self::Snapshot(r) => &r.worldline,
        }
    }

    pub fn seq(&self) -> u64 {
        match self {
            Self::Commitment(r) => r.seq,
            Self::Outcome(r) => r.seq,
            Self::Snapshot(r) => r.seq,
        }
    }

    pub fn receipt_hash(&self) -> [u8; 32] {
        match self {
            Self::Commitment(r) => r.receipt_hash,
            Self::Outcome(r) => r.receipt_hash,
            Self::Snapshot(r) => r.receipt_hash,
        }
    }

    pub fn prev_hash(&self) -> Option<[u8; 32]> {
        match self {
            Self::Commitment(r) => r.prev_hash,
            Self::Outcome(r) => r.prev_hash,
            Self::Snapshot(r) => r.prev_hash,
        }
    }

    pub fn timestamp(&self) -> TemporalAnchor {
        match self {
            Self::Commitment(r) => r.timestamp,
            Self::Outcome(r) => r.timestamp,
            Self::Snapshot(r) => r.timestamp,
        }
    }

    pub fn as_commitment(&self) -> Option<&CommitmentReceipt> {
        match self {
            Self::Commitment(r) => Some(r),
            _ => None,
        }
    }

    pub fn as_outcome(&self) -> Option<&OutcomeReceipt> {
        match self {
            Self::Outcome(r) => Some(r),
            _ => None,
        }
    }

    pub fn as_snapshot(&self) -> Option<&SnapshotReceipt> {
        match self {
            Self::Snapshot(r) => Some(r),
            _ => None,
        }
    }

    pub fn set_receipt_hash(&mut self, hash: [u8; 32]) {
        match self {
            Self::Commitment(r) => r.receipt_hash = hash,
            Self::Outcome(r) => r.receipt_hash = hash,
            Self::Snapshot(r) => r.receipt_hash = hash,
        }
    }
}

impl From<&Receipt> for ReceiptRef {
    fn from(value: &Receipt) -> Self {
        Self {
            worldline: value.worldline().clone(),
            seq: value.seq(),
            receipt_hash: value.receipt_hash(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use wll_types::identity::IdentityMaterial;

    fn worldline(seed: u8) -> WorldlineId {
        WorldlineId::derive(&IdentityMaterial::GenesisHash([seed; 32]))
    }

    #[test]
    fn evidence_bundle_generates_digest() {
        let bundle = EvidenceBundle::from_references(vec!["obj://a".into(), "obj://b".into()]);
        assert_ne!(bundle.digest, [0; 32]);
    }

    #[test]
    fn decision_helpers_work() {
        assert!(Decision::Accepted.is_accepted());
        assert!(
            Decision::Rejected {
                reason: "x".into()
            }
            .is_rejected()
        );
    }

    #[test]
    fn receipt_ref_captures_envelope() {
        let receipt = Receipt::Commitment(CommitmentReceipt {
            worldline: worldline(3),
            seq: 7,
            receipt_hash: [9; 32],
            prev_hash: Some([8; 32]),
            timestamp: TemporalAnchor::new(100, 1, 0),
            proposal_hash: [1; 32],
            commitment_id: CommitmentId::new(),
            class: CommitmentClass::ContentUpdate,
            intent: "test".into(),
            requested_caps: vec!["cap".into()],
            evidence: EvidenceBundle::from_references(vec![]),
            decision: Decision::Accepted,
            policy_hash: [2; 32],
        });

        let reference = ReceiptRef::from(&receipt);
        assert_eq!(reference.seq, 7);
        assert_eq!(reference.receipt_hash, [9; 32]);
    }

    #[test]
    fn outcome_hash_is_deterministic() {
        let outcome = OutcomeRecord {
            effects: vec![],
            proofs: vec![],
            state_updates: vec![StateUpdate {
                key: "k".into(),
                value: Value::from(42),
            }],
            metadata: BTreeMap::new(),
        };
        let h1 = outcome.outcome_hash();
        let h2 = outcome.outcome_hash();
        assert_eq!(h1, h2);
    }

    #[test]
    fn receipt_kind_accessors() {
        let receipt = Receipt::Outcome(OutcomeReceipt {
            worldline: worldline(1),
            seq: 2,
            receipt_hash: [0; 32],
            prev_hash: None,
            timestamp: TemporalAnchor::zero(),
            commitment_receipt_hash: [0; 32],
            outcome_hash: [0; 32],
            accepted: true,
            effects: vec![],
            proofs: vec![],
            state_updates: vec![],
            metadata: BTreeMap::new(),
        });

        assert_eq!(receipt.kind(), ReceiptKind::Outcome);
        assert!(receipt.as_outcome().is_some());
        assert!(receipt.as_commitment().is_none());
        assert!(receipt.as_snapshot().is_none());
    }
}
